# Кейс-задача №5

Аналитический обзор кейс-задачи №1 (алгоритм на Python) по критериям качества.

---

## Функциональность

Программа решает поставленную задачу: находит сумму отрицательных элементов массива, расположенных между минимальным и максимальным элементами. Корректно обрабатывает основные случаи:
- обычный массив с отрицательными и положительными числами
- массив, где min и max стоят рядом (результат = 0)
- массив, где min левее max и наоборот
- пустой ввод

Граничные случаи тоже учтены: если между min и max нет элементов, возвращается 0. Если массив пустой — тоже 0.

Что не реализовано: обработка некорректного ввода (буквы вместо цифр). Сейчас программа упадёт с ValueError. Для учебной задачи это допустимо, но в реальном приложении нужен try-except.

---

## Производительность

Алгоритм работает за O(N) — два прохода по массиву: первый для поиска min/max, второй для суммирования. Это оптимально, быстрее не сделать, потому что нужно как минимум один раз просмотреть все элементы.

Память O(1) — не создаются дополнительные структуры данных, только переменные для индексов и суммы.

Для массивов любого разумного размера (миллионы элементов) программа отработает за доли секунды. Узких мест нет.

---

## Удобство использования

Интерфейс минималистичный: ввод чисел через пробел в одной строке, вывод — одно число. Для консольной утилиты это нормально.

Что можно улучшить:
- добавить подсказку при запуске ("Введите числа через пробел:")
- выводить более информативный результат ("Сумма отрицательных между min и max: -5")
- обрабатывать ошибки ввода с понятным сообщением

Сейчас программа молча ждёт ввода и молча выводит число — не очень user-friendly, но для учебной задачи сойдёт.

---

## Безопасность

Для данной программы вопрос безопасности не особо актуален — она не работает с файлами, сетью или конфиденциальными данными. Просто читает stdin и пишет в stdout.

Потенциальная проблема: если подать на вход очень длинную строку, Python попытается распарсить её всю в память. Теоретически можно устроить DoS, но это надуманный сценарий для консольной утилиты.

В целом — безопасность в рамках задачи обеспечена.

---

## Масштабируемость

Текущая реализация — монолитная функция. Если нужно расширить функционал (например, искать не сумму, а произведение, или работать с несколькими массивами), придётся менять код.

Как улучшить:
- вынести логику поиска min/max в отдельную функцию
- параметризовать условие фильтрации (не только отрицательные, а любой предикат)
- добавить возможность читать данные из файла

Для учебной задачи масштабируемость избыточна, но если бы это была библиотека — стоило бы продумать API.

---

## Сопровождаемость

Код читаемый: понятные имена переменных (min_value, max_value, min_index, max_index, total), логика разбита на шаги. Функция `sum_negative_between_min_max` делает ровно то, что написано в названии.

Комментариев нет, но код достаточно простой, чтобы понять его без комментариев. Для более сложной программы стоило бы добавить docstring с описанием параметров и возвращаемого значения.

Структура файла стандартная: функция + main + `if __name__ == "__main__"`. Легко импортировать в другой модуль.

---

## Переносимость

Программа написана на чистом Python без внешних зависимостей. Работает на любой системе, где есть Python 3 (Windows, Linux, macOS).

Никаких платформо-зависимых конструкций нет. Можно запустить хоть на Raspberry Pi, хоть в Docker-контейнере.

---

## Качество кода

Код соответствует PEP 8 (стиль Python): snake_case для переменных и функций, отступы 4 пробела, пустые строки между функциями.

Используется enumerate() вместо ручного счётчика — это pythonic way. Срезы списка (values[start:end]) тоже идиоматичны.

Что можно улучшить:
- добавить type hints (def sum_negative_between_min_max(values: list[int]) -> int)
- добавить docstring
- вынести магические числа, если бы они были

В целом код чистый, без хаков и костылей.

---

## Тестирование

В репозитории нет автоматических тестов. Есть примеры в answer.md, но это ручная проверка.

Для полноценного тестирования нужно добавить:
- unit-тесты на основную функцию (pytest или unittest)
- тесты граничных случаев: пустой массив, один элемент, все элементы одинаковые, min и max на краях
- тесты на некорректный ввод (если добавить обработку ошибок)

Пример теста:
```python
def test_basic():
    assert sum_negative_between_min_max([5, -2, 1, -3, 4]) == -2

def test_no_negatives():
    assert sum_negative_between_min_max([1, 2, 3]) == 0

def test_empty():
    assert sum_negative_between_min_max([]) == 0
```

---

## Выявленные проблемы и способы решения

| Проблема | Решение |
|----------|---------|
| Нет обработки некорректного ввода | Обернуть парсинг в try-except, выводить сообщение об ошибке |
| Нет подсказок для пользователя | Добавить print() с инструкцией перед input() |
| Нет автоматических тестов | Написать pytest-тесты, добавить в CI |
| Нет type hints | Добавить аннотации типов для функций |
| Нет docstring | Добавить описание функции, параметров и возвращаемого значения |
| Жёсткая привязка к stdin | Добавить возможность передавать данные как аргумент или читать из файла |

Большинство этих проблем — не критичные для учебной задачи, но важны для production-кода.
